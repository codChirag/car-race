<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Street Racer — HTML / CSS / JS</title>
<style>
  :root{
    --bg:#0b1020; --road:#2b2b2b; --stripe:#e9e9e9; --grass:#0b3b16;
    --hud:#eaf2ff;
    --accent:#ff4d4f;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
  body{background:linear-gradient(180deg,#071026,#021018); display:flex; align-items:center; justify-content:center; padding:12px;}
  .wrapper{width:100%; max-width:1100px; display:grid; grid-template-columns: 1fr 320px; gap:18px; align-items:start;}
  @media(max-width:920px){ .wrapper{ grid-template-columns: 1fr; } }
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.008)); padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.03); color:var(--hud); box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  canvas{width:100%; display:block; border-radius:10px; background:var(--bg); box-shadow: inset 0 6px 30px rgba(0,0,0,0.6);}
  h1{margin:0 0 6px 0; font-size:18px}
  .controls{display:flex; gap:8px; margin-top:8px; flex-wrap:wrap}
  .btn{padding:8px 10px; border-radius:8px; cursor:pointer; border:0; background:var(--accent); color:#081018; font-weight:800}
  .small{padding:6px 8px; background:rgba(255,255,255,0.03); color:var(--hud)}
  .hud{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .badge{background:rgba(255,255,255,0.03); padding:8px 10px; border-radius:8px; color:var(--hud); font-weight:700}
  .mobile-controls{display:none; gap:10px; justify-content:center; margin-top:10px}
  .touch-btn{width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-weight:800;color:var(--hud);user-select:none}
  @media(max-width:920px){ .mobile-controls{display:flex} .controls{display:none} }
  .footer{font-size:12px;color:rgba(234,242,255,0.7); margin-top:8px}
  .overlay {
    position:absolute; inset:0; display:flex; align-items:flex-start; justify-content:center; pointer-events:none;
  }
  .center-ui { pointer-events:auto; margin-top:50px; background:rgba(0,0,0,0.45); padding:16px; border-radius:10px; text-align:center;}
  .center-ui button{margin-top:8px}
</style>
</head>
<body>
  <div class="wrapper">
    <div class="panel" id="gamePanel" style="position:relative;">
      <h1>Street Racer</h1>
      <div style="position:relative;">
        <canvas id="game" width="900" height="600" aria-label="Car racing canvas"></canvas>
        <div class="overlay" id="overlay"></div>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
        <div class="hud">
          <div class="badge">Score: <span id="score">0</span></div>
          <div class="badge">Speed: <span id="speed">0</span> km/h</div>
          <div class="badge">Laps: <span id="laps">0</span></div>
        </div>
        <div class="hud">
          <div class="badge">High: <span id="high">0</span></div>
        </div>
      </div>
      <div class="mobile-controls" id="mobileControls">
        <div class="touch-btn" id="leftBtn">◀</div>
        <div style="display:flex; gap:8px;">
          <div class="touch-btn" id="brakeBtn">▮</div>
          <div class="touch-btn" id="accelBtn">▲</div>
        </div>
        <div class="touch-btn" id="rightBtn">▶</div>
      </div>
      <div class="footer">Controls: Arrow keys / WASD to steer & accelerate. Mobile: use on-screen buttons.</div>
    </div>

    <div class="panel">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <div style="font-weight:800">Settings</div>
          <div style="color:rgba(234,242,255,0.7); font-size:13px">Tweak difficulty and visuals</div>
        </div>
        <div><button class="btn" id="restart">Restart</button></div>
      </div>

      <div style="margin-top:12px;">
        <label class="small">Traffic density:
          <select id="density" style="margin-left:8px; padding:6px; border-radius:6px; background:transparent; color:inherit">
            <option value="0.6">Low</option>
            <option value="1" selected>Medium</option>
            <option value="1.5">High</option>
            <option value="2">Insane</option>
          </select>
        </label>
      </div>

      <div style="margin-top:12px;">
        <label class="small">Max speed (km/h):
          <input id="maxSpeed" type="range" min="80" max="320" value="200" style="width:160px; margin-left:8px">
        </label>
      </div>

      <div style="margin-top:12px;">
        <div style="font-weight:700">How to play</div>
        <ol style="color:rgba(234,242,255,0.75); font-size:13px">
          <li>Accelerate and avoid traffic</li>
          <li>Overtake cars for points</li>
          <li>Don't crash — collisions slow you down</li>
        </ol>
      </div>

      <div style="margin-top:12px; display:flex; gap:8px;">
        <button class="small" id="toggleMusic">Toggle Sound</button>
        <button class="small" id="toggleParticles">Particles</button>
      </div>
    </div>
  </div>

<script>
/*
  Street Racer — Endless top-down racing demo
  - Canvas-based
  - Player car moves left/right and accelerates
  - Procedural traffic cars spawn from top
  - Collision detection, scoring, speedometer, high score
  - Touch buttons for mobile
  - No external assets required (cars drawn via canvas)
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// HUD
const scoreEl = document.getElementById('score');
const speedEl = document.getElementById('speed');
const lapsEl = document.getElementById('laps');
const highEl = document.getElementById('high');
const densitySel = document.getElementById('density');
const maxSpeedSlider = document.getElementById('maxSpeed');

const overlay = document.getElementById('overlay');
const restartBtn = document.getElementById('restart');
const toggleMusicBtn = document.getElementById('toggleMusic');
const toggleParticlesBtn = document.getElementById('toggleParticles');

let DPR = Math.max(1, window.devicePixelRatio || 1);
function fit() {
  // keep 3:2 ratio sized to container
  const rect = canvas.getBoundingClientRect();
  const containerW = rect.width;
  const containerH = Math.min(window.innerHeight * 0.7, containerW * 2/3);
  canvas.style.width = containerW + 'px';
  canvas.style.height = containerH + 'px';
  W = Math.floor(containerW * DPR);
  H = Math.floor(containerH * DPR);
  canvas.width = W; canvas.height = H;
}
window.addEventListener('resize', fit);
fit();

/* ---------------- Game Settings ---------------- */
let settings = {
  laneCount: 3,
  roadWidthRatio: 0.55, // percent of canvas width used by road
  spawnRate: parseFloat(densitySel.value), // multiplier
  maxSpeedKm: parseInt(maxSpeedSlider.value,10),
  particles: true
};

densitySel.addEventListener('change', ()=> settings.spawnRate = parseFloat(densitySel.value));
maxSpeedSlider.addEventListener('input', ()=> settings.maxSpeedKm = parseInt(maxSpeedSlider.value,10));
toggleParticlesBtn.addEventListener('click', ()=> { settings.particles = !settings.particles; toggleParticlesBtn.textContent = settings.particles ? 'Particles' : 'Particles (off)'; });

/* ---------------- Utility ---------------- */
function rand(a,b){ return a + Math.random()*(b-a); }
function rndInt(a,b){ return Math.floor(rand(a,b+1)); }

/* ---------------- Game State ---------------- */
let player, traffic = [], particles = [];
let score = 0, laps = 0;
let highScore = parseInt(localStorage.getItem('racerHigh') || '0',10) || 0;
highEl.textContent = highScore;

let keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

/* Mobile buttons */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const accelBtn = document.getElementById('accelBtn');
const brakeBtn = document.getElementById('brakeBtn');
[leftBtn,rightBtn,accelBtn,brakeBtn].forEach(b=>{ if(b) {
  b.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys[b.id.replace('Btn','')] = true; }, {passive:false});
  b.addEventListener('touchend', (e)=>{ e.preventDefault(); keys[b.id.replace('Btn','')] = false; }, {passive:false});
  b.addEventListener('mousedown', ()=> keys[b.id.replace('Btn','')] = true);
  b.addEventListener('mouseup', ()=> keys[b.id.replace('Btn','')] = false);
}});

/* ---------------- Road layout ---------------- */
function roadLayout() {
  const roadWidth = W * settings.roadWidthRatio;
  const sideWidth = (W - roadWidth)/2;
  const laneWidth = roadWidth / settings.laneCount;
  return { roadWidth, sideWidth, laneWidth, roadLeft: sideWidth };
}

/* ---------------- Player car ---------------- */
function resetPlayer() {
  const layout = roadLayout();
  // place player in center lane bottom area
  const lane = Math.floor(settings.laneCount/2);
  const laneX = layout.roadLeft + lane*layout.laneWidth + layout.laneWidth/2;
  player = {
    x: laneX,
    y: H - layout.laneWidth*1.6,
    lane,
    speed: 0, // pixels per second
    angle: 0,
    maxSpeed: settings.maxSpeedKm * 0.4, // convert to px/sec scale
    accel: 800,
    brake: 1600,
    w: layout.laneWidth*0.6,
    h: layout.laneWidth*1.1,
    invuln: 0 // invulnerable frames
  };
  score = 0; laps = 0;
  traffic = []; particles = [];
  updateHUD();
}
resetPlayer();

/* ---------------- Traffic car generator ---------------- */
function spawnTraffic() {
  const layout = roadLayout();
  const lane = rndInt(0, settings.laneCount-1);
  const laneX = layout.roadLeft + lane*layout.laneWidth + layout.laneWidth/2;
  // spawn above viewport with random offset
  const y = -rndInt(80, 400);
  // pick random car width/height variation
  const w = layout.laneWidth*0.6 * rand(0.9,1.1);
  const h = layout.laneWidth*1.05 * rand(0.9,1.15);
  const speed = rand(player.maxSpeed*0.25, player.maxSpeed*0.9);
  traffic.push({
    x: laneX,
    y, w, h, lane,
    speed,
    color: `hsl(${rndInt(0,360)}, ${rndInt(55,80)}%, ${rndInt(35,55)}%)`,
    id: Math.random().toString(36).slice(2,8)
  });
}

/* Spawn logic timer */
let spawnTimer = 0;

/* ---------------- Particles ---------------- */
function addParticle(x,y,dx,dy,color) {
  if (!settings.particles) return;
  particles.push({x,y,dx,dy,life:0.6,color,age:0});
}

/* ---------------- Physics & Update ---------------- */
let last = performance.now();
function update() {
  const now = performance.now();
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;

  // read controls
  const left = keys['arrowleft'] || keys['a'] || keys['left'];
  const right = keys['arrowright'] || keys['d'] || keys['right'];
  const accel = keys['arrowup'] || keys['w'] || keys['up'] || keys['accel'];
  const brake = keys['arrowdown'] || keys['s'] || keys['down'] || keys['brake'];

  // adjust player speed
  if (accel) player.speed += player.accel * dt;
  else player.speed -= player.brake * 0.6 * dt; // natural deceleration
  if (brake) player.speed -= player.brake * dt;

  // clamp speed
  player.speed = Math.max(0, Math.min(player.maxSpeed, player.speed));

  // steering - smooth lane change (not teleport)
  const layout = roadLayout();
  const turnSpeed = 6 + (player.speed / player.maxSpeed) * 8; // faster speed harder to turn
  if (left) player.x -= turnSpeed * 60 * dt;
  if (right) player.x += turnSpeed * 60 * dt;

  // avoid leaving road sides - friction and slow
  const roadLeft = layout.roadLeft + player.w/2;
  const roadRight = layout.roadLeft + layout.roadWidth - player.w/2;
  if (player.x < roadLeft) {
    player.x = roadLeft;
    player.speed *= 0.9;
    addParticle(player.x, player.y + player.h*0.3, rand(-40,40), rand(10,40), '#6b3');
  } else if (player.x > roadRight) {
    player.x = roadRight;
    player.speed *= 0.9;
    addParticle(player.x, player.y + player.h*0.3, rand(-40,40), rand(10,40), '#6b3');
  }

  // move traffic relative to player speed (player fixed vertically)
  for (let i = traffic.length-1; i >= 0; i--) {
    const t = traffic[i];
    // relative speed: incoming speed - player's forward speed
    t.y += (t.speed + player.speed * 0.6) * dt;
    // if below canvas, remove
    if (t.y - t.h > H + 200) traffic.splice(i,1);
  }

  // spawn traffic probabilistically
  spawnTimer += dt * settings.spawnRate * (1 + player.speed / player.maxSpeed);
  if (spawnTimer > 0.7) {
    spawnTimer = 0;
    // vary spawn based on speed and density
    if (Math.random() < 0.9) spawnTraffic();
    // sometimes spawn double on high density
    if (Math.random() < 0.25 * settings.spawnRate) spawnTraffic();
  }

  // collision detection (AABB)
  const px1 = player.x - player.w/2, px2 = player.x + player.w/2;
  const py1 = player.y - player.h/2, py2 = player.y + player.h/2;
  for (let t of traffic) {
    const tx1 = t.x - t.w/2, tx2 = t.x + t.w/2;
    const ty1 = t.y - t.h/2, ty2 = t.y + t.h/2;
    const overlap = !(px2 < tx1 || px1 > tx2 || py2 < ty1 || py1 > ty2);
    if (overlap) {
      // collision happened
      handleCollision(t);
    }
  }

  // score increases with distance/speed
  score += player.speed * dt * 0.02;
  scoreEl.textContent = Math.floor(score);

  // update particles
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx * dt * 60;
    p.y += p.dy * dt * 60;
    p.age += dt;
    if (p.age > p.life) particles.splice(i,1);
  }

  // update high score
  if (score > highScore) {
    highScore = Math.floor(score);
    localStorage.setItem('racerHigh', highScore);
    highEl.textContent = highScore;
  }

  // update HUD speed (convert px/sec to rough km/h feel)
  const displayedKmh = Math.round(player.speed * 1.8);
  speedEl.textContent = displayedKmh;
  lapsEl.textContent = laps;
}

/* ---------------- Collision response ---------------- */
function handleCollision(t) {
  // knockback: reduce player speed, bounce traffic down
  player.speed *= 0.45;
  t.y += 80 * (player.speed/50 + 0.5);
  // add particles and small camera shake
  addParticle(player.x - player.w*0.3, player.y, rand(-60,-10), rand(-30,30), '#ffb3b3');
  addParticle(player.x + player.w*0.3, player.y, rand(10,60), rand(-30,30), '#ffb3b3');

  // penalize score
  score = Math.max(0, score - 120);
  // temporary invulnerability to avoid instant double-hit
  player.invuln = 0.6;

  // reduce traffic speed briefly
  t.speed *= 0.6;
}

/* ---------------- Drawing ---------------- */
function drawRoad() {
  const layout = roadLayout();
  // draw grass sides
  ctx.fillStyle = '#043014';
  ctx.fillRect(0, 0, W, H);
  // road
  ctx.fillStyle = '#2b2b2b';
  ctx.fillRect(layout.roadLeft, 0, layout.roadWidth, H);

  // lane stripes
  const laneW = layout.laneWidth;
  ctx.strokeStyle = '#eaeaea';
  ctx.lineWidth = Math.max(2, DPR*2);
  ctx.setLineDash([20*DPR, 30*DPR]);
  for (let i = 1; i < settings.laneCount; i++) {
    const x = layout.roadLeft + i*laneW;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  ctx.setLineDash([]);
  // side lines
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = Math.max(2, DPR*1.5);
  ctx.strokeRect(layout.roadLeft+2*DPR, 0, layout.roadWidth-4*DPR, H);
}

function drawCar(x,y,w,h,color,ctxRef) {
  const c = ctxRef || ctx;
  c.save();
  c.translate(x,y);
  // body shadow
  c.fillStyle = 'rgba(0,0,0,0.35)';
  c.fillRect(-w/2+6*DPR, -h/2+8*DPR, w, h);
  // main body
  c.fillStyle = color;
  roundRect(c, -w/2, -h/2, w, h, Math.min(w,h)*0.12);
  c.fill();
  // windshield
  c.fillStyle = 'rgba(255,255,255,0.12)';
  roundRect(c, -w*0.22, -h*0.46, w*0.44, h*0.34, 4*DPR);
  c.fill();
  // wheels
  c.fillStyle = '#0b0b0b';
  const wheelW = w*0.18, wheelH = h*0.22;
  c.fillRect(-w/2+6*DPR, -h/2+wheelH/2, wheelW, wheelH);
  c.fillRect(w/2-6*DPR-wheelW, -h/2+wheelH/2, wheelW, wheelH);
  c.fillRect(-w/2+6*DPR, h/2-wheelH*1.5, wheelW, wheelH);
  c.fillRect(w/2-6*DPR-wheelW, h/2-wheelH*1.5, wheelW, wheelH);
  c.restore();
}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* ---------------- Render frame ---------------- */
function render() {
  // clear
  ctx.clearRect(0,0,W,H);

  // scale for DPR
  ctx.save();
  ctx.scale(DPR, DPR);

  drawRoad();

  // draw traffic - behind player based on y sorting
  const sorted = traffic.slice().sort((a,b)=> a.y - b.y);
  for (let t of sorted) {
    drawCar(t.x/DPR, t.y/DPR, t.w/DPR, t.h/DPR, t.color);
  }

  // draw player
  drawCar(player.x/DPR, player.y/DPR, player.w/DPR, player.h/DPR, '#ff4d4f');

  // draw particles
  for (let p of particles) {
    ctx.fillStyle = p.color;
    ctx.globalAlpha = Math.max(0, 1 - (p.age / p.life));
    ctx.beginPath();
    ctx.arc(p.x/DPR, p.y/DPR, 3 + 2*(1 - p.age/p.life), 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  ctx.restore();

  // overlay HUD done via DOM
}

/* ---------------- Game loop ---------------- */
let running = true;
function loop() {
  if (!running) return;
  update();
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------------- UI actions ---------------- */
restartBtn.addEventListener('click', ()=> {
  resetPlayer();
});
toggleMusicBtn.addEventListener('click', ()=> {
  // placeholder for audio toggle
  alert('Sound toggled (placeholder) — sound not included in this demo.');
});

/* ---------------- Helpers & initial spawns ---------------- */
// Pre-scale coordinates according to DPR to keep crisp drawing
function scaleAllForDPR(){
  // everything drawn in device pixels; we'll keep player coords in device pixels
  // convert existing values if necessary (here we reset player)
  resetPlayer();
}
scaleAllForDPR();

// initial traffic
for (let i=0;i<6;i++){ spawnTraffic(); }

/* ---------------- Window focus pause/resume ---------------- */
window.addEventListener('blur', ()=> running = false);
window.addEventListener('focus', ()=> { if(!running){ running = true; last = performance.now(); requestAnimationFrame(loop);} });

/* ---------------- Touch friendly: show mobile controls when small screen ---------------- */
function adaptMobileUI(){
  const mc = document.getElementById('mobileControls');
  if (window.innerWidth <= 920) mc.style.display = 'flex';
  else mc.style.display = 'none';
}
window.addEventListener('resize', adaptMobileUI);
adaptMobileUI();

/* ---------------- Prevent scroll on arrow keys for mobile browsers ---------------- */
window.addEventListener('keydown', (e) => {
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.code)) e.preventDefault();
});

/* ---------------- Start game ready message (center overlay) ---------------- */
const center = document.createElement('div');
center.className = 'center-ui';
center.style.pointerEvents = 'auto';
center.innerHTML = `<div style="font-size:20px;font-weight:800">Street Racer</div>
  <div style="margin-top:6px;color:rgba(234,242,255,0.8)">Tap / press keys to drive. Avoid traffic and score points.</div>
  <button id="startPlay" style="margin-top:10px;" class="btn">Start Driving</button>`;
overlay.appendChild(center);
document.getElementById('startPlay').addEventListener('click', ()=> {
  overlay.removeChild(center);
  last = performance.now();
  running = true;
  requestAnimationFrame(loop);
});

/* ---------------- END of file ---------------- */
</script>
</body>
</html>
